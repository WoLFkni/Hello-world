集合关系：排序、查找
线性关系：线性表、栈、队列
树形关系：树
图关系：图

逻辑关系+基本操作
存储实现，基本操作的实现，典型应用

基本操作：构造类（建立），属性类（查询），数据操纵类（修改视为先删除再插入），遍历类，典型应用类
存储结构：在内存中的表示 顺序存储，链式存储。

算法：确定性，有穷性，可行性，有输入（0/若干），有输出（0/若干）
算法的基本要求：正确性，可读性（注释），健壮性（不同输入要有相同反应），时间效率（执行时间），空间效率（算法执行期间内所需要的最大内存空间）

执行时间：运行后度量（机器的计时功能），运行前分析（几个方面的影响因素：机器的运行速度（主频和字长），编译后代码的质量（编译优化策略不同），书写程序所用的语言（语言越高级，运行效率低，编程效率高），问题的规模和数据的分布，算法采用的策略和方法）

时间频度
标准操作（即基本语句）的执行速度来度量
执行次数越多，时间花费越多，执行次数成为时间频度
和处理的数据规模n有关，表示为n的函数T(n)
循环语句：计算实际运行次数
分支语句（if else）：按照执行语句多的那个分支计算

时间复杂度
n趋于无穷
T(n)/f(n) 的极限为一个非零常数，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度，称大O表示法
即$\exists C 和 N_0, \forall n > N_0$，有T(n)<=C`*`f(n).则O(f(n))为算法的时间复杂度
时间复杂度由时间频度函数中的最高次项决定，不带系数

- 执行次数和数据规模n的变化无关的语句可以不计入
- 数据规模对执行语句的重复次数都在循环中，循环控制条件和循环变量的变化次数和循环体的执行次数接近一致，故只需看循环体的执行次数即可。

```
s = 0;
for (i = 0; i < n; i++){
	for (j = 0; j < n; j++){
		s = s + i + j;
		cout << s;
	}
}
```
当内外循环次数相互关系时时间复杂度依旧为$O(n^2)$ 

常量阶$O(1)$
对数阶$O(log_2n)$（对半对半查找）
线性阶$O(n)$
线性对数阶$O(nlog_2n)$
平方阶$O(n^2)$
（易性算法）

---
（顽性算法）
立方阶$O(n^3)$
幂阶$O(2^n)$汉诺塔
阶乘阶$O(n!)$
N幂阶$O(n^N)$

求和定理
T1(n)、T2(n)是程序P1和P2的运行时间，$T1(n)是 O(f(n))的$，，$T2(n)是 O(g(n))的$先运行1再运行2
$T1(n)+T2(n) 是 O(MAX(f(n),g(n)))的$
求积定理
$T1(n)*T2(n) 是 O(f(n)*g(n))的$

```
for (int i = n; i >= 1; i = i / 4){
	cout << i;
}
```

```
count = 0;
for (k = 1; k <= n; k *= 2){
	for (j = 1; j <= n; j++){
		cou
	}
}
```